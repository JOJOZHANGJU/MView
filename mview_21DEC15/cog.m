function [L1, skew, kurt, M, C, zc, sd] = cog(varargin)%COG  - compute spectral Center-Of-Gravity measures%%	usage:  [L1, skew, kurt, M, C, zc, sd] = cog(s, t, ...)%% Given signal vector S computes spectral center of gravity measures at offset time T (msecs)%% S may be an AUDIO object, a MAVIS-compatible array of struct data, or a vector of samples % followed by a scalar sampling rate (in this case use cog(s, sr, t, ...)%% Returns 1st spectral moment L1 (mean frequency), SKEWness, and KURTosis% optionally returns spectral mode M and median C, number of zero crossings ZC, std. dev. SD%% The following optional 'NAME',VALUE argument pairs are supported (defaults shown as {VALUE}):%	'ALG'	 - algorithm (short-term AVeraGing/single WINdowed spectrum):  {'AVG'} | 'WIN'%	'SPEC'	 - magnitude/power spectrum type:  {'MAG'} | 'POW'%	'PREEMP' - audio pre-emphasis (0<=mu<=1):  {1} (pass [] to use adaptive pre-emphasis)%	'CUTOFF' - cutoff frequency for analysis (Hz):  {sRate/2}%	'WSIZE'  - analysis window (centered on offset time T; msecs):  {50}%	'FRAME'  - number of FFT analysis points (default is next highest power of 2 containing WSIZE)%	'AVGW'   - short-term averaging window size (msecs):  {6}%	'OLAP'   - short-term averaging window overlap (msecs):  {1}%% Examples:% % Assume audio object A, MAVIS DATA, signal vector S with sampling rate SR% % Compute COG measures at offset 100 msecs% >> [L1, skew, kur] = cog(A, 100, 'AVGW',12,'OLAP',2)		% 12 msec short-term avg, 2 msec shift% >> [L1, skew, kur] = cog(A, 100, 'ALG','WIN','WSIZE',100)	% single window, 100 msec frame% >> [L1, skew, kur] = cog(DATA, 100, 'SPEC','POW','CUTOFF',7800)	% power spectrum, 7.8kHz cutoff% >> [L1, skew, kur] = cog(S,SR,100,'PREEMP',[],'FRAME',512)		% adaptive pre-emphasis, 512 pt FFT%% Adapted from Forrest, K., Weismer, G., Milenkovic, P., & Dougall, R. (1988) "Statistical % analysis of word-initial voiceless obstruents:  preliminary data," JASA, 84, 115-123.% % mkt 03/01 from M. Matthies' MITSYN procedure Scanx_COG.MCL %	defaultsalg = 'AVG';			% algorithmspec = 'MAG';			% spectrum typemu = 1;					% pre-emphasiscutoff = [];			% cutoff freq (Hz)wSize = 50;				% analysis frame size (msecs)frame = [];				% number of FFT analysis pointsavgW = 6;				% short-term avg window (msecs)oLap = 1;				% short-term avg overlap (msecs)% parse argsif nargin < 2,	eval('help cog');	return;end;nargs = nargin;if isa(varargin{1},'audio'),	% audio object	s = varargin{1};	sr = s.SRATE;	s = double(s);elseif isstruct(varargin{1}),	% struct data array (assumes audio is 1st element)	s = varargin{1};	s = s(1);	sr = s.SRATE;	s = s.SIGNAL;	if size(s,2) > 1, error('expecting audio in DATA(1)'); end;elseif nargin>2,	s = varargin{1};			% vector, srate pair	sr = s{2};	s = s{1};else,	error('argument error');end;t = varargin{2};for ai = 3 : 2 : length(varargin),	switch upper(varargin{ai}),		case 'ALG', alg = varargin{ai+1};		case 'SPEC', spec = varargin{ai+1};		case 'PREEMP', mu = varargin{ai+1};		case 'CUTOFF', cutoff = varargin{ai+1};		case 'WSIZE', wSize = varargin{ai+1};		case 'FRAME', frame = varargin{ai+1};		case 'AVGW', avgW = varargin{ai+1};		case 'OLAP', oLap = varargin{ai+1};		otherwise, error(sprintf('unrecognized option (%s)', varargin{ai}));	end;end;%	get analysis framets = floor(t*sr/1000)+1;			% msecs->samplesns = round(wSize/1000*sr);			% frame (msecs->samples)head = ts - round(ns/2);if head < 1, head = 1; end;tail = head + ns - 1;if tail > length(s),	tail = length(s);	head = tail - ns + 1;end;s = s(head:tail);s = s(:)';% 	pre-emphasizeif isempty(mu), 	% adaptive (cf. Markel & Gray (1976) Linear Prediction of Speech, p216)	R0 = (s * s');					% short-time autocorrelation	R1 = (s * [0 s(1:end-1)]');	mu = R1 / R0;					% optimal pre-emphasis coefficient	if mu < 0, mu = 0; end;			% clipend;if mu < 0 | mu > 1, error(sprintf('pre-emphasis coefficient error (%g)', mu)); end;if mu > 0,	s = filter([1 -mu], 1, s);		% s[n] = s[n] - mu*s[n-1]end;%	process audioif isempty(frame),	frame = 2^floor(log(ns)/log(2));	% analysis frame:  next highest power of 2 less 1end;switch upper(spec),	case 'MAG', ps = 0;	case 'POW', ps = 1;	otherwise, error(sprintf('unrecognized spectrum type (%s)', spec));end;switch upper(alg),	case 'AVG',		avgW = floor(avgW*sr/1000);		% cvt window size to samples		shift = floor(oLap*sr/1000);		% cvt window overlap to samples		nFrames = round(length(s)/shift)+1;	% # frames to average		w = hamming(avgW)';				% window		p = zeros(frame, nFrames);			% preallocate frame spectra		sx = [zeros(1,avgW) , s , zeros(1,avgW)];	% pad		si = ceil(avgW/2);					% sample index		for fi = 1 : nFrames,				% frame index			pf = fft(w .* sx(si:si+avgW-1), frame*2);			if ps,		% power spectrum				pf = real(pf).^2 + imag(pf).^2;			else,		% magnitude spectrum				pf = abs(pf);			end;			p(:,fi) = pf(1:frame)';			% drop upper reflection			si = si + shift;				% shift window		end;		p = mean(p,2);						% averaged spectrum	case 'WIN',		p = fft(hanning(ns)' .* s, frame*2);		p = p(1:frame)';					% drop upper reflection		if ps,		% power spectrum			p = real(p).^2 + imag(p).^2;		else,		% magnitude spectrum			p = abs(p);		end;			otherwise,		error(sprintf('unrecognized analysis algorithm (%s)', alg));end;%	compute spectral momentsif isempty(cutoff), cutoff = floor(sr/2); end;upb = round(cutoff * frame * 2 / sr);		% upper bound cutoffif upb > frame, upb = frame; end;			% NyquistF = linspace(1,upb,upb-1)' * sr/(frame*2);	% frequency binsp = p(1:upb);								% power (1-based)np = p ./ sum(p);							% normalized powernp = np(2:end);								% drop DCL1 = sum(F .* np);							% momentsFL = F - L1;L2 = sum(FL.^2 .* np);L3 = sum(FL.^3 .* np);L4 = sum(FL.^4 .* np);skew = L3/L2^1.5;kurt = L4/L2^2 - 3;% 	compute spectral mode[v,k] = max(np);M = F(k);% 	compute spectral mediank = find(cumsum(np) >= .5);C = F(k(1));%	compute zero crossingszc = sum(abs(diff(s>=0)));% compute std. deviationsd = std(s);