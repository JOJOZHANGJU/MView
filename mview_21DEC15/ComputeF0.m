function [F0,sr] = ComputeF0(s, alg, validRange, outSR, varargin);%COMPUTEF0  - continous pitch estimator%%	usage:  [F0,sr] = ComputeF0(s, alg, validRange, outSR, ...)%% This procedure compute a continuous pitch contour F0 from speech vector S% using one of three ALGorithms:  'YIN' | 'PRAAT' (default) | 'STRAIGHT'%% S may be an AUDIO object, a MAVIS-compatible array of structs % (first element assumed to be audio), a string interpreted as % a MS WAV filename, or a {S,SRATE} cell object%% values outside of VALIDRANGE are set to NaN (default [80 300])%% values resampled to OUTSR Hz rate if specified%% returns F0 and optional sampling rate SR%% additional supported 'NAME',VALUE parameters passed to YINF0:%	F0THR - upper threshold for valid F0%	HOP   - interval between estimates (samples)%% NOTE that to use the PRAAT algorithm you must have either a symbolic link or alias% within the same directory as this file that resolves to a copy of the Praat program%% use of STRAIGHT requires a copy of Kawahara's Straight package%% see also COMPUTEF01, YINF0, PRAATF0, EXSTRAIGHTSOURCE% mkt 10/08% parse argsif nargin < 1,	eval('help ComputeF0');	return;end;if nargin < 2 || isempty(alg),	alg = 'PRAAT';end;if nargin < 3 || isempty(validRange), 	validRange = [80 300];end;if nargin < 4, outSR = []; end;fName = '';if isa(s,'audio'),	sr = s.SRATE;	s = double(s);elseif isstruct(s),	sr = s(1).SRATE;	s = s(1).SIGNAL;elseif ischar(s),	fName = s;	[p,f,e] = fileparts(fName);	if isempty(e), fName = fullfile(p,[f,'.wav']); end;	[s,sr] = wavread(fName);elseif iscell(s),	sr = s{2};	s = s{1};else,	error('argument error (signal)');end;% switch by algorithmswitch upper(alg),	case 'YIN',		F0 = YinF0(s, sr, varargin{:});	case 'PRAAT',		if isempty(fName),			if max(abs(s)) > 1, s = s / max(abs(s)); end;			fName = 'TempPraatData.wav';			try,				audiowrite(fName,s,sr);			catch,				wavwrite(s,sr,fName);			end		end;		F0 = PraatF0(fName);		delete(fName);	case 'STRAIGHT',		F0 = exstraightsource(s,sr);	otherwise,		error('unrecognized algorithm (%s)', alg);end;F0(find(F0<validRange(1) | F0>validRange(2))) = NaN;% resample if necessaryif isempty(outSR),	dur = 1000*length(s)/sr;	sr = sr * length(F0) / length(s);else,	idx = isnan(F0);	F0(idx) = 0;	k = linspace(1,length(F0),round(length(s)/sr*outSR));	F0 = interp1(F0,k);	idx = interp1(double(idx),k);	F0(find(idx>0)) = NaN;	sr = outSR;end;F0 = F0(:);