function mOut = lp_peaks(lpState, action, varargin)%LP_PEAKS  - MVIEW labeling procedure (label all extrema within range)%% This procedure labels extrema on the clicked trajectory within the current% selection range.  Its behavior is determined by the modification state:% control selects minima, shift selects maxima.  Selected extrema are chosen% on FWIN filtered signal, and must be within SLOP% of clicked extremum.%% Note that if the clicked trajectory has multiple displayed components operates on the % first displayed dimension only.% 04/08 mktidString = 'LP_PEAKS';screen = '<SCREEN>';%	branch by action (2nd argument)switch upper(action),		%-----------------------------------------------------------------------------% CONFIG:  handle configuration%% 	returns MOUT = new internal state% 	mOut = [] flags cancelled	case 'CONFIG',		mOut = DoConfig(lpState, idString, screen);		return;		%-----------------------------------------------------------------------------% DOWN:  handle mouseDown%%	arg(1)	- cursor loc (msecs)%	arg(2)	- immediate (nonzero if label set by menu command)	case 'DOWN',		mOut = [];			% no state update needed		if length(varargin) > 1, 		% menu label creation:  use default handler			label = struct('NAME','', 'OFFSET',[], 'VALUE',[], 'HOOK',[]);			feval(lpState.CALLER,'MAKELBL', label);			return; 			end;		MakeLabels(lpState, varargin{1});		%-----------------------------------------------------------------------------% EXPORT:  label export handler%%	arg(1)	- state.LABELS%	arg(2)	- state.NAME	case 'EXPORT',		labels = varargin{1};		vName = varargin{2};		if isempty(labels), return; end;% open the file		isNew = ~exist(lpState.FNAME,'file');		if strcmp(lpState.FNAME,screen),			fid = 1;		else,			fid = fopen(lpState.FNAME, 'at');			if fid == -1,				error(sprintf('error attempting to open %s', lpState.FNAME));			end;		end;		% write headers if necessary		if isNew,			fprintf(fid, '\nSOURCE\tTRAJ\tOFFSET\tVALUE\tPERCNT\tTARGET\tTYPE\n');		end;		% append label data		for k = 1 : length(labels),			q = labels(k).HOOK;			if isempty(q) || ~iscell(q),				fprintf(fid,'%s\t%s\t%.1f\t%.1f\n',vName,labels(k).NAME,labels(k).OFFSET,labels(k).VALUE);			else,				fprintf(fid,'%s\t%s\t%.1f\t%.1f\t%.2f\t%.2f\t%s\n',vName,labels(k).NAME,labels(k).OFFSET,labels(k).VALUE,q{1},q{2},q{3});			end;		end;		% clean up		if fid > 1, 			fclose(fid);			fprintf('\nLabels from %s appended to %s\n', vName, lpState.FNAME);		end;%-----------------------------------------------------------------------------% PLOT:  plot label into the current axes%%	args:	- label to plot%			- yLim of current axis%%	return MOUT = updated label	case 'PLOT',				% default handler		if isempty(lpState.CALLER), lpState.CALLER = GetCaller; end;		label = feval(lpState.CALLER,'LPLOT', varargin{1}, varargin{2}, gcbf);% set default motion handler		set(label.HANDS(1), 'buttonDownFcn', sprintf('%s(''LMOVE'',''DOWN'');',lpState.CALLER));		mOut = label;%-----------------------------------------------------------------------------% error	otherwise,		error(['LP_PEAKS:  unrecognized action (', varargin{2}, ')']);	end;%=============================================================================% MAKELABELSfunction MakeLabels(lpState, offset)mod = get(gcbf, 'selectionType');state = get(gcbf, 'userData');		% retrieve stateif isfield(state,'CLICKINFO') & ~isempty(state.CLICKINFO),	clickInfo = state.CLICKINFO;else,	clickInfo = [];end;				% get clicked trajectoryif isempty(clickInfo),	clickInfo = [1 1 1];end;ti = clickInfo(1);				% clicked trajectory (index into data)tpi = clickInfo(2);				% index into displayed TEMPMAPsn = state.TEMPMAP(tpi);s = state.DATA(ti).SIGNAL;sr = state.DATA(ti).SRATE;if length(clickInfo) > 3,		% multidimensional	comp = clickInfo(4:end);	switch clickInfo(3),		case 1, 			ci = find(comp);		case 2,			if sum(comp) == state.DATA(ti).NCOMPS,				ci = 7;		% velocity magnitude			else,				ci = find(comp) + 3;			end;		case 3,			if sum(comp) == state.DATA(ti).NCOMPS,				ci = 11;	% acceleration magnitude			else,				ci = find(comp) + 7;			end;	end;	if length(ci) > 1, ci = ci(1); end;		% take 1st of multiple componentselse,	if clickInfo(3) >= 6 & sr < 2000,		% velocity		s(2:end-1) = (s(3:end) - s(1:end-2))./2;		s(1) = s(2);		s(end) = s(end-1);		if clickInfo(3)>6, s = abs(s); end;	end;	ci = 1;end;% if sr > 2000,% 	offset = [];					% speech; use current cursor offset% 	label = struct('NAME', sn, ...		% clicked signal name% 					'OFFSET', offset, ...		% use supplied offset% 					'VALUE', [], ...		% 					'HOOK', []);% 	feval(lpState.CALLER,'MAKELBL', label);		% create the label% 	return;% end;% mvt:  retain clicked component from displayed selectionif offset < state.HEAD, offset = state.HEAD; elseif offset > state.TAIL, offset = state.TAIL; endoffset = offset - state.HEAD;hts = floor([state.HEAD,state.TAIL,offset]*sr/1000) + 1;s = s(hts(1):hts(2),ci);				% find extrema on filtered signal (FWIN sample rect MA filter)fs = filtfilt(ones(1,lpState.FWIN)./lpState.FWIN,1,s);infl = diff([0 ; diff(fs)] > 0);if strcmp(mod, 'extend'),		% shift:  maxima	extrema = find(infl < 0);	ts = 'max';else,							%  else:  minima	extrema = find(infl > 0);	ts = 'min';end;[v,k] = min(abs(extrema - hts(3)));idx = extrema(k);				% nearest min/maxminS = min(s);maxS = max(s);target = (s(idx) - minS) ./ (maxS - minS);se = (s(extrema) - minS) ./ (maxS - minS);vals = s(extrema);k = find(se<target-lpState.SLOP | se>target+lpState.SLOP);extrema(k) = [];vals(k) = [];for k = 1 : length(extrema),	state = get(gcbf, 'userData');	state.MOVEMODE = 'LBL_SILENT';		% twiddle state to avoid annotation dialog	set(gcbf, 'userData', state);	offset = 1000*(extrema(k) + hts(1) - 1)/sr;	label = struct('NAME', sn, ...		% clicked signal name					'OFFSET', offset, ...						'VALUE', vals(k), ...					'HOOK', []);	label.HOOK = {(vals(k)-minS)./(maxS-minS),target,ts};	feval(lpState.CALLER,'MAKELBL', label);		% create the labelend;%=============================================================================% DEFCFG  - set default configuration%%	returns default values for lpStatefunction lpState = DefCfg(idString, screen)lpState = struct('SOURCE', idString, ...					'FNAME', screen, ...	% export filename					'SLOP', .15, ...		% +/- percentage of clicked extremum					'FWIN', 5, ...			% filter window length (samps)					'CALLER', GetCaller);				%=============================================================================% DOCONFIG- config handler%%   returns non-empty lpState on OK, [] on cancelfunction lpState = DoConfig(lpState, idString, screen)width = 320; height = 280;figPos = CenteredDialog(gcf, width, height);% initialize if necessaryif isempty(lpState) | ~strcmp(lpState.SOURCE, idString),	lpState = DefCfg(idString, screen);end;cfg = dialog('Name', idString, ...	'Tag', upper(lpState.CALLER), ...	'menubar', 'none', ...	'Position', figPos, ...	'KeyPressFcn', 'set(gcbf,''UserData'',1);uiresume', ...	'UserData', 0);% aboutblurb = ['This procedure labels extrema on the clicked trajectory within the current ', ...		'selection range.  Its behavior is determined by the modification state:  ', ...		'control selects minima, shift selects maxima.  Selected extrema are chosen ', ...		'on FWIN filtered signal, and must be within SLOP% of clicked extremum.'];uicontrol(cfg, ...	'Style', 'frame', ...	'Position', [10 height-120 width-20 100]);uicontrol(cfg, ...	'Style', 'text', ...	'HorizontalAlignment', 'left', ...	'String', blurb, ...	'Position', [13 height-115 width-26 90]);% export filenameuicontrol(cfg, ...	'Style','text', ...	'HorizontalAlignment', 'right', ...	'String','Export filename:', ...	'Units', 'characters', ...	'Position', [1 8 21 2]);ffh = uicontrol(cfg, ...	'Style', 'edit', ...	'HorizontalAlignment', 'left', ...	'String', [' ',lpState.FNAME], ...	'Units', 'characters', ...	'Position', [23 8.4 20 2], ...	'Callback', 'set(gcbf,''UserData'',1);uiresume');% filter windowuicontrol(cfg, ...	'Style','text', ...	'HorizontalAlignment', 'right', ...	'String','Filter Length:', ...	'Units', 'characters', ...	'Position', [1 6 21 2]);xfh = uicontrol(cfg, ...	'Style', 'edit', ...	'HorizontalAlignment', 'left', ...	'String', sprintf(' %d',lpState.FWIN), ...	'Units', 'characters', ...	'Position', [23 6.4 20 2], ...	'Callback', 'set(gcbf,''UserData'',1);uiresume');% slopuicontrol(cfg, ...	'Style','text', ...	'HorizontalAlignment', 'right', ...	'String','SLOP (% of max:min):', ...	'Units', 'characters', ...	'Position', [1 4 21 2]);sfh = uicontrol(cfg, ...	'Style', 'edit', ...	'HorizontalAlignment', 'left', ...	'String', sprintf(' %.2f',lpState.SLOP), ...	'Units', 'characters', ...	'Position', [23 4.4 20 2], ...	'Callback', 'set(gcbf,''UserData'',1);uiresume');% OK, cancel buttonsuicontrol(cfg, ...		% buttons	'Position',[width/2-70 15 60 25], ...	'String','OK', ...	'Callback','set(gcbf,''UserData'',1);uiresume');uicontrol(cfg, ...	'Position',[width/2+10 15 60 25], ...	'String','Cancel', ...	'Callback','uiresume');% wait for inputuiwait(cfg);if get(cfg, 'UserData'),	slop = str2num(get(sfh, 'string'));	if isempty(slop), slop = lpState.SLOP; end;	if slop<0, slop=0; elseif slop>1, slop=1; end;	fwin = str2num(get(xfh, 'string'));	if isempty(fwin), fwin = lpState.FWIN; end;	if fwin<5, fwin=5; elseif fwin>100, fwin=100; end;	lpState.SLOP = slop;	lpState.FWIN = fwin;	fn = strtok(get(ffh,'string'));	if isempty(fn) || strcmp(fn,screen), 		fn = screen;	else,		[p,f,e] = fileparts(fn);		if isempty(e), e = '.lab'; end;		fn = fullfile(p,[f,e]);	end;	lpState.FNAME = fn;else,	lpState = [];end;delete(cfg);%=============================================================================% PARSETEMPMAP  - parse displayed TEMPMAP entry%%	usage:  [ti, mod, comp] = ParseTemp(loadedString, sel, comps)%% returns trajectory index TI (into DATA), MODification code, active COMPonentsfunction [ti,mod,comp,allComps] = ParseTempMap(loadedString, sel, comps)mods = {'SPECT','F0','RMS','ZC','VEL','ABSVEL'};		% supported monodimensional data modificationsallComps = 0;											% true if all components selectedif all(sel > 'Z'), sel = upper(sel); end;% find prefix movement selector (movement '', velocity 'v', acceleration 'a')if sel(1) > 'Z',	if sel(1)=='v', mod = 2; else, mod = 3; end;	sel = sel(2:end);else,	mod = 1;end;% find suffix component selectork = findstr(sel,'_');if isempty(k),			% movement	k = find(sel>'Z');	if isempty(k),		comp = [];				% all		allComps = 1;	else,		comp = sel(k:end);		% xyz		sel = sel(1:k-1);	end;else,					% mono-dimensional mods	comp = sel(k+1:end);		% SPECT, F0, RMS, ZC, VEL, ABSVEL	if isempty(strmatch(comp, mods, 'exact')),		comp = [];				% traj name with form FOO_BAH	else,		sel = sel(1:k-1);	end;end;% find trajectory indexti = strmatch(upper(sel), loadedString, 'exact');if isempty(ti),	ti = 0;						% not found	return;end;% multi-component trajectoriesif comps{ti} > 1,	if isempty(comp),	% unspecified (all)		comp = [1 1 comps{ti}>2];	else,				% specified		comp = [any(comp=='x') , any(comp=='y') , any(comp=='z')];	end;% monodimensional dataelse,	if isempty(comp),		mod = 1;		% data	else,		mod = strmatch(comp, mods, 'exact') + 1;	end;	comp = [];end;%=============================================================================% GETCALLER  - get calling procedure namefunction caller = GetCallerstack = dbstack;[p, caller] = fileparts(stack(end).name);